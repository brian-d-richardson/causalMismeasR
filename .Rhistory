cov.e = cov.e, B = B.grid[ii], mc.seed = mc.seed)
psi <- get.psi.glm.mccs(x = gfmla.naive)
et <- Sys.time()
return(c(B = B.grid[ii],
Time = et - st,
psi = psi))
}) %>%
t() %>%
as.data.frame() %>%
`colnames<-`(c("B", "Time", paste0("psi", 0:5))) %>%
pivot_longer(cols = !B)
## plot results
ggplot(data = B.search,
aes(x = B,
y = value)) +
geom_line() +
facet_wrap(~ name,
scales = "free") +
labs(y = "") +
ggtitle("Score Values and Computation Time by Number of MC Replicates B")
## number of MC replicates
B <- 30
## G-formula
gfmla.res <- fit.gfmla.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = gfmla.args)
data = datstar
args = gfmla.args
## unpack arguments
list2env(args, envir = environment())
## subset to complete cases if using case-cohort data
if ("R" %in% colnames(data)) {
data <- data[data$R == 1 | data$Y == 1,]
}
## add case-cohort weights of 1 if not supplied
if ( !("cc.wts" %in% colnames(data)) ) {
data$cc.wts <- 1
}
## store values
n <- nrow(data)                               # sample size
len.est <- ncol(model.matrix(                 # dimension of model parameters
terms(as.formula(formula)), data = data))
len.a <- length(a)                            # number of exposure values
L <- data[, grepl("L", colnames(data))]       # covariates
# fit outcome model
root <- fit.glm(data = data, args = args, return.var = F)$est
# estimate E{Y(a)} for each supplied a value
EYa <- vapply(X = a,
FUN.VALUE = 0,
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
mean(inv.link(a.mod.mat %*% root))
})
a
aa <- a[ai]
ai = 1
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
mean(inv.link(a.mod.mat %*% root))
is.vector(a)
# estimate E{Y(a)} for each supplied a value
EYa <- vapply(X = a,
FUN.VALUE = 0,
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
mean(inv.link(a.mod.mat %*% root))
})
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
mean(inv.link(a.mod.mat %*% root))
# estimate E{Y(a)} for each supplied a value
EYa <- vapply(X = a,
FUN.VALUE = 0,
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
mean(inv.link(a.mod.mat %*% root))
})
load_all()
load_all()
## G-formula
gfmla.res <- fit.gfmla.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = gfmla.args)
load_all()
load_all()
load_all()
## G-formula
gfmla.res <- fit.gfmla.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = gfmla.args)
## unpack arguments
list2env(args, envir = environment())
## subset to complete cases if using case-cohort data
if ("R" %in% colnames(data)) {
data <- data[data$R == 1 | data$Y == 1,]
}
## add case-cohort weights of 1 if not supplied
if ( !("cc.wts" %in% colnames(data)) ) {
data$cc.wts <- 1
}
## store values
n <- nrow(data)                              # sample size
len.est <- ncol(model.matrix(                # dimension of model parameters
terms(as.formula(formula)), data = data))
len.a <- length(a)                            # number of exposure values
L <- data[, grepl("L", colnames(data))]      # covariates
## fit outcome model
root <- fit.glm.mccs(data = data, args = args,
cov.e = cov.e, B = B, mc.seed = mc.seed,
return.var = F)$est
## estimate E{Y(a)} for each supplied a value
EYa <- vapply(X = 1:len.a,
FUN.VALUE = 0,
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
mean(inv.link(a.mod.mat %*% root))
})
names(EYa) <- paste0("EYa.", 1:len.a)
ghat = c(root, EYa)
## create MCCS GLM estimating function
get.psi.glm.mccs <- make.mccs(
get.psi = get.psi.glm, data = data, args = args,
cov.e = cov.e, B = B, mc.seed = mc.seed)
# sandwich variance estimate if requested
evar = matrix(NA, len.est + len.a, len.est + len.a)
if (return.var) {
evar <- tryCatch(
expr = get.sand.est(
ghat = ghat,
n = n,
get.psi = function(x) {
ght <- head(x, -len.a)
EYa <- tail(x, len.a)
cbind(
get.psi.glm.mccs(x = ght, return.sums = F),
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
EYa[aa] - inv.link(a.mod.mat %*% ght)
}))}),
warning = function(w) {message(w); evar},
error = function(e) {message(e); evar})
}
evar <- tryCatch(
expr = get.sand.est(
ghat = ghat,
n = n,
get.psi = function(x) {
ght <- head(x, -len.a)
EYa <- tail(x, len.a)
cbind(
get.psi.glm.mccs(x = ght, return.sums = F),
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
EYa[aa] - inv.link(a.mod.mat %*% ght)
}))}),
warning = function(w) {message(w); evar},
error = function(e) {message(e); evar})
ghatr
ghat
x = gjat
x = ghat
ght <- head(x, -len.a)
EYa <- tail(x, len.a)
cbind(
get.psi.glm.mccs(x = ght, return.sums = F),
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
EYa[aa] - inv.link(a.mod.mat %*% ght)
}))}),
get.sand.est(
ghat = ghat,
n = n,
get.psi = function(x) {
ght <- head(x, -len.a)
EYa <- tail(x, len.a)
cbind(
get.psi.glm.mccs(x = ght, return.sums = F),
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
EYa[aa] - inv.link(a.mod.mat %*% ght)
}))})
x
ght <- head(x, -len.a)
EYa <- tail(x, len.a)
cbind(
get.psi.glm.mccs(x = ght, return.sums = F),
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
EYa[aa] - inv.link(a.mod.mat %*% ght)
}))}),
cbind(
get.psi.glm.mccs(x = ght, return.sums = F),
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(ai) {
if (is.vector(a)) {
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
} else {
aa <- a[ai,]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
do.call("rbind", replicate(n, aa, simplify = F)),
L))
}
EYa[aa] - inv.link(a.mod.mat %*% ght)
}))
ai = 1
is.vector(a)
aa <- a[ai]
a.mod.mat <- mod.mat(
terms(as.formula(formula)),
data = data.frame(
A = do.call("rbind", replicate(n, aa, simplify = F)),
L))
EYa[aa] - inv.link(a.mod.mat %*% ght)
load_all()
## G-formula
gfmla.res <- fit.gfmla.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = gfmla.args)
cbind(est = round(gfmla.res$est, 2),
stde = round(sqrt(diag(gfmla.res$var)), 2))
## IPW arguments
ipw.args <- list(formula = ipw.formula,
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## IPW estimation
ipw.res <- fit.ipw.mccs(
data = datstar,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = ipw.args)
cbind(est = round(ipw.res$est, 2),
stde = round(sqrt(diag(ipw.res$var)), 2))
## arguments for double robust estimation
dr.args <- list(formula = formula,
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## Double Robust
dr.res <- fit.dr.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = dr.args)
cbind(est = round(dr.res$est, 2),
stde = round(sqrt(diag(dr.res$var)), 2))
seed <- 1                                      # random seed
n <- 800                                       # sample size
B <- 2#30                                        # MC replicates
mc.seed <- 123                                 # MC seed
pi.cc <- 0.25                                   # case-cohort proportion
gg <- c(0.4, 0.15, 0.15, 0.2,
0.1, 0.1, 0, -0.1)                     # Y|A,L parameters
g <- gg[1:4] + 0.5*gg[5:8]                     # MSM parameters
formula <- "~A1*L + A2*L + A3*L"               # Y|A,L model formula
ps.formula <- "~L"                             # PS model formula
inv.link <- inv.ident;                         # MSM link function
d.inv.link <- d.inv.ident;                     # MSM derivative of link
vare <- 0.001#0.05                                   # variance of A1, A2
cov.e <- diag(c(vare, vare, 0))                # measurement error variance
coef.a.l <- matrix(
data = c(0, 0.4, 0, -0.4, 0.2, -0.1),        # coefs in A|L model
nrow = 3, byrow = T)
var.a.l <- c(0.09, 0.09, 0.09)                 # variance of A|L
# generate data -----------------------------------------------------------
set.seed(seed)                                 # seed for reproducibility
L <- runif(n)                                  # confounder
A <- mvrnorm(n = n,                            # true exposure
mu = c(0, 0, 0),
Sigma = diag(var.a.l)) +
cbind(1, L) %*% t(coef.a.l)
colnames(A) = paste0("A", 1:3)
Astar <- A + mvrnorm(n = n,                    # mismeasured exposure
m = c(0, 0, 0),
Sigma = cov.e)
Y_prob <- cbind(1, A, L, A*L) %*% gg           # mean of binary outcome
Y_prob[Y_prob < 0] <- 0                        # correct Y_prob in rare cases
Y_prob[Y_prob > 1] <- 1
Y <- rbinom(n, 1, Y_prob)                      # binary outcome
colnames(A) <- colnames(Astar) <-
c("A1", "A2", "A3")
R <- rbinom(n, 1, pi.cc)                       # c-c sampling
A[R == 0 & Y == 0] <-
Astar[R == 0 & Y == 0] <- NA
dat0 <- data.frame(Y, A, L, R)                 # oracle data
datstar <- data.frame(Y, Astar, L, R)          # mismeasured data
a <- as.data.frame(matrix(
c(-0.01709859, -0.41727369, -0.0531144,
0.20031219, -0.19979007,  0.1498574,
0.41804918,  0.01691357,  0.3536388),
nrow = 3, ncol = 3, byrow = T))
colnames(a) <- colnames(A)
# estimate case-cohort weights --------------------------------------------
pi.cc.hat <- mean(datstar$R[datstar$Y == 0])
dat0$cc.wts <- datstar$cc.wts <- (1 - datstar$Y) * datstar$R / pi.cc.hat + Y
# store values for estimation ---------------------------------------------
args <- list(formula = formula,                         # arguments for fitting
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## estimate case-cohort weights
pi.cc.hat <- mean(datstar$R[datstar$Y == 0])
datstar$cc.wts <- (1 - datstar$Y) * datstar$R / pi.cc.hat + Y
## corrected doubly robust estimator
dr.mccs <- fit.dr.mccs(data = datstar, args = args, a = a,
cov.e = cov.e, B = B, mc.seed = mc.seed)
a <- apply(A, 2, function(x)
quantile(x, c(0.25, 0.5, 0.75), na.rm = T))
colnames(a) <- colnames(A)
pi.cc.hat <- mean(datstar$R[datstar$Y == 0])
dat0$cc.wts <- datstar$cc.wts <- (1 - datstar$Y) * datstar$R / pi.cc.hat + Y
args <- list(formula = formula,                         # arguments for fitting
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## estimate case-cohort weights
pi.cc.hat <- mean(datstar$R[datstar$Y == 0])
datstar$cc.wts <- (1 - datstar$Y) * datstar$R / pi.cc.hat + Y
## corrected doubly robust estimator
dr.mccs <- fit.dr.mccs(data = datstar, args = args, a = a,
cov.e = cov.e, B = B, mc.seed = mc.seed)
cbind(est = round(dr.res$est, 2),
stde = round(sqrt(diag(dr.res$var)), 2))
## corrected doubly robust estimator
dr.cc.mccs <- fit.dr.mccs(data = datstar, args = args, a = a,
cov.e = cov.e, B = B, mc.seed = mc.seed)
cbind(est = round(dr.cc.mccs$est, 2),
stde = round(sqrt(diag(dr.cc.mccs$var)), 2))
## install the package
devtools::install_github(repo = "brian-d-richardson/mismex",
ref = "main")
knitr::opts_chunk$set(echo = TRUE)
## install the package
devtools::install_github(repo = "brian-d-richardson/mismex",
ref = "main")
