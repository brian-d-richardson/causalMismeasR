n = 2000                                  # sample size
seed = 1                                  # random number seed
mc.seed <- 123                            # MCCS seed
cov.e <- 0.16                             # var(epsilon)
inv.link <- inv.ident                     # inverse link
d.inv.link <- d.inv.ident                 # derivative of inverse link
g <- c(1.5, 0.7, 0.9, -0.6, -0.7, 0.4)    # outcome model parameters
formula <- "~A*L1 + A*L2"                 # outcome model formula
ps.formula <- "~L1 + L2"                  # propensity score model formula
ipw.formula <- "~A"                       # MSM formula
## generate data
set.seed(seed)
L1 <- rbinom(n, 1, 0.5)                                  # confounder 1
L2 <- rnorm(n, 1, sqrt(0.5))                             # confounder 2
A <- rnorm(n, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))            # exposure
a <- seq(min(A), max(A), length = 4)                     # grid of exposures
EY <- inv.link(model.matrix(as.formula(formula)) %*% g)  # mean of outcome
Y <- rnorm(n, EY, sqrt(0.16))                            # outcome
Astar <- A + rnorm(n, 0, sqrt(cov.e))                    # mismeasured A
datstar <- data.frame(Y, A = Astar, L1, L2)              # mismeasured data
head(datstar, 5)
## arguments for double robust estimation
dr.args <- list(formula = formula,
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
B = 1
cov.e = 0.00001
n = 2000                                  # sample size
seed = 1                                  # random number seed
mc.seed <- 123                            # MCCS seed
inv.link <- inv.ident                     # inverse link
d.inv.link <- d.inv.ident                 # derivative of inverse link
g <- c(1.5, 0.7, 0.9, -0.6, -0.7, 0.4)    # outcome model parameters
formula <- "~A*L1 + A*L2"                 # outcome model formula
ps.formula <- "~L1 + L2"                  # propensity score model formula
ipw.formula <- "~A"                       # MSM formula
## generate data
set.seed(seed)
L1 <- rbinom(n, 1, 0.5)                                  # confounder 1
L2 <- rnorm(n, 1, sqrt(0.5))                             # confounder 2
A <- rnorm(n, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))            # exposure
a <- seq(min(A), max(A), length = 4)                     # grid of exposures
EY <- inv.link(model.matrix(as.formula(formula)) %*% g)  # mean of outcome
Y <- rnorm(n, EY, sqrt(0.16))                            # outcome
Astar <- A + rnorm(n, 0, sqrt(cov.e))                    # mismeasured A
datstar <- data.frame(Y, A = Astar, L1, L2)              # mismeasured data
head(datstar, 5)
## arguments for double robust estimation
dr.args <- list(formula = formula,
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## Double Robust
dr.res <- fit.dr.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = dr.args)
data = datstar
args = dr.args
## unpack arguments
list2env(args, envir = environment())
## store values
n <- nrow(data)                               # sample size
len.est <- ncol(model.matrix(                 # dimension of model parameters
terms(as.formula(formula)), data = data))
len.a <- length(a)                            # size of exposure grid
ind.A <- grepl("A", colnames(data))
A <- data[,ind.A]                             # exposure
len.A <- sum(ind.A)                           # dimension of exposure
len.ps <- ncol(model.matrix(                  # dimension of ps parameters
terms(as.formula(ps.formula)), data = data))
L <- data[, grepl("L", colnames(data))]       # covariates
# compute marginal mean and covariance of A if not supplied
if (is.null(ps.wts)) {
if (is.null(mean.a)) { mean.a <- colMeans(as.matrix(A)) }
if (is.null(cov.a)) { if (is.vector(A)) cov.a <- var(A) else cov.a <- cov(A) }
}
ps.wts = NULL
# compute marginal mean and covariance of A if not supplied
if (is.null(ps.wts)) {
if (is.null(mean.a)) { mean.a <- colMeans(as.matrix(A)) }
if (is.null(cov.a)) { if (is.vector(A)) cov.a <- var(A) else cov.a <- cov(A) }
}
mean.a = NULL
cov.a = NULL
# compute marginal mean and covariance of A if not supplied
if (is.null(ps.wts)) {
if (is.null(mean.a)) { mean.a <- colMeans(as.matrix(A)) }
if (is.null(cov.a)) { if (is.vector(A)) cov.a <- var(A) else cov.a <- cov(A) }
}
# fit weighted outcome model
root <- fit.ipw(data = data, args = args, start = start, return.var = F,
ps.wts = ps.wts,
mean.a = mean.a, cov.a = cov.a,
coef.a.l = coef.a.l, var.a.l = var.a.l)$est
start = NULL
start <- rep(0, len.est)
# compute marginal mean and covariance of A if not supplied
if (is.null(ps.wts)) {
if (is.null(mean.a)) { mean.a <- colMeans(as.matrix(A)) }
if (is.null(cov.a)) { if (is.vector(A)) cov.a <- var(A) else cov.a <- cov(A) }
}
# fit weighted outcome model
root <- fit.ipw(data = data, args = args, start = start, return.var = F,
ps.wts = ps.wts,
mean.a = mean.a, cov.a = cov.a,
coef.a.l = coef.a.l, var.a.l = var.a.l)$est
outcome.params <- head(root, len.est)
outcome.params
# estimate E{Y(a)} for each supplied a value
EYa <- vapply(X = a,
FUN.VALUE = 0,
FUN = function(aa) {
a.mod.mat <- mod.mat(terms(as.formula(formula)),
data = data.frame(A = aa, L))
mean(inv.link(a.mod.mat %*% outcome.params))
})
names(EYa) <- paste0("EYa.", 1:len.a)
ghat <- c(root, EYa)
# sandwich variance estimate if requested
evar = matrix(NA, len.est, len.est)
if (return.var) {
evar <- tryCatch(
expr = get.sand.est(
ghat = ghat,
n = n,
get.psi = function(x) {
ght <- head(x, len.est + len.A*(1+len.ps))
ght.out <- head(x, len.est)
coef.a.l <- matrix(x[len.est + 1:(len.A*len.ps)],
ncol = len.ps, byrow = F)
var.a.l <- exp(x[len.est + (len.A*len.ps) + 1:len.A])
EYa <- tail(x, len.a)
cbind(
# weighted outcome model
get.psi.ipw(
data = data, g = ght, args = args, return.sums = F,
mean.a = mean.a, cov.a = cov.a),
# PS weights
get.psi.ps(
data = data, ps.formula = ps.formula,
coef.a.l = coef.a.l, var.a.l = var.a.l,
return.sums = F),
# E{Y(a)}
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(aa) {
a.mod.mat <- mod.mat(terms(as.formula(formula)),
data = data.frame(A = a[aa], L))
EYa[aa] - inv.link(a.mod.mat %*% ght.out)
}))}),
warning = function(w) {message(w); matrix(NA, len.est, len.est)},
error = function(e) {message(e); matrix(NA, len.est, len.est)})
}
return.var = T
# sandwich variance estimate if requested
evar = matrix(NA, len.est, len.est)
if (return.var) {
evar <- tryCatch(
expr = get.sand.est(
ghat = ghat,
n = n,
get.psi = function(x) {
ght <- head(x, len.est + len.A*(1+len.ps))
ght.out <- head(x, len.est)
coef.a.l <- matrix(x[len.est + 1:(len.A*len.ps)],
ncol = len.ps, byrow = F)
var.a.l <- exp(x[len.est + (len.A*len.ps) + 1:len.A])
EYa <- tail(x, len.a)
cbind(
# weighted outcome model
get.psi.ipw(
data = data, g = ght, args = args, return.sums = F,
mean.a = mean.a, cov.a = cov.a),
# PS weights
get.psi.ps(
data = data, ps.formula = ps.formula,
coef.a.l = coef.a.l, var.a.l = var.a.l,
return.sums = F),
# E{Y(a)}
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(aa) {
a.mod.mat <- mod.mat(terms(as.formula(formula)),
data = data.frame(A = a[aa], L))
EYa[aa] - inv.link(a.mod.mat %*% ght.out)
}))}),
warning = function(w) {message(w); matrix(NA, len.est, len.est)},
error = function(e) {message(e); matrix(NA, len.est, len.est)})
}
# sandwich variance estimate if requested
evar = matrix(NA, len.est, len.est)
if (return.var) {
evar <- tryCatch(
expr = get.sand.est(
ghat = ghat,
n = n,
get.psi = function(x) {
ght <- head(x, len.est + len.A*(1+len.ps))
ght.out <- head(x, len.est)
coef.a.l <- matrix(x[len.est + 1:(len.A*len.ps)],
ncol = len.ps, byrow = F)
var.a.l <- exp(x[len.est + (len.A*len.ps) + 1:len.A])
EYa <- tail(x, len.a)
cbind(
# weighted outcome model
get.psi.ipw(
data = data, g = ght, args = args, return.sums = F),
# PS weights
get.psi.ps(
data = data, ps.formula = ps.formula,
coef.a.l = coef.a.l, var.a.l = var.a.l,
return.sums = F),
# E{Y(a)}
vapply(X = 1:len.a,
FUN.VALUE = numeric(n),
FUN = function(aa) {
a.mod.mat <- mod.mat(terms(as.formula(formula)),
data = data.frame(A = a[aa], L))
EYa[aa] - inv.link(a.mod.mat %*% ght.out)
}))}),
warning = function(w) {message(w); matrix(NA, len.est, len.est)},
error = function(e) {message(e); matrix(NA, len.est, len.est)})
}
evar
load_all()
load_all()
## Double Robust
dr.res <- fit.dr(
data = datstar,
a = a,
return.var = TRUE,
args = dr.args)
dr.res
## Double Robust
dr.res <- fit.dr(
data = datstar,
a = a,
return.var = TRUE,
args = dr.args, ps.wts = rep(1, n))
dr.res
load_all()
## Double Robust
dr.res <- fit.dr.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = dr.args)
dr.res
## Double Robust
dr.res <- fit.dr.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = dr.args, ps.wts = rep(1, n))
dr.res
## Known PS weights
ps.wts <- dnorm(dat0$A, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))
ps.wts
## Known PS weights
ps.wts <- 1 / dnorm(dat0$A, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))
## Known PS weights
ps.wts <- dnorm(dat0$A, mean(dat0$A), sd(dat0$A)) /
dnorm(dat0$A, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))
ps.wts
## Double Robust (known weights)
dr.res.known.wts <- fit.dr.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = dr.args,
ps.wts = ps.wts)
dr.res.known.wts
cbind(est = round(dr.res.known.wts$est, 2),
stde = round(sqrt(diag(dr.res.known.wts$var)), 2))
cbind(est = round(dr.res$est, 2),
stde = round(sqrt(diag(dr.res$var)), 2))
cbind(est = round(dr.res$est, 2),
stde = round(sqrt(diag(dr.res$var)), 2))
cbind(est = round(dr.res.known.wts$est, 2),
stde = round(sqrt(diag(dr.res.known.wts$var)), 2))
## install the package
devtools::install_github(repo = "brian-d-richardson/mismex",
ref = "main")
## install the package
devtools::install_github(repo = "brian-d-richardson/mismex",
ref = "main")
knitr::opts_chunk$set(echo = TRUE)
## load the package
library(mismex)
## install the package
devtools::install_github(repo = "brian-d-richardson/mismex",
ref = "main")
knitr::opts_chunk$set(echo = TRUE)
## load the package
library(mismex)
#' \itemize{
#' \item{`inv.link`: a function, inverse link function}
#' \item{`d.inv.link`: a function, derivative of inv.link}
#' \item{`formula`: a character string of outcome model formula}
#' \item{`ps.formula`: a character string of propensity model formula}
#' }
#'
#' @return individual or summation estimating function values
#'
#' @export
get.psi.ipw <- function(data, g, args, ps.wts = NULL, return.sums = T) {
## unpack arguments
list2env(args, envir = environment())
## design matrix
X <- mod.mat(trms = terms(as.formula(formula)),
data = data)
## extract dimensions
len.msm <- ncol(X)                                         # dim of msm params
len.ps <- ncol(model.matrix(terms(as.formula(ps.formula)), # PS model params
data = data))                  # dim of ps params
ind.A <- grepl("A", colnames(data))                        # exposure columns
len.A <- sum(ind.A)
## get PS weights if not supplied
if (is.null(ps.wts)) {
# extract PS model params
mean.a <- colMeans(as.matrix(A)) }
cov.a <- var(A) else cov.a <- cov(A)
#' \itemize{
#' \item{`inv.link`: a function, inverse link function}
#' \item{`d.inv.link`: a function, derivative of inv.link}
#' \item{`formula`: a character string of outcome model formula}
#' \item{`ps.formula`: a character string of propensity model formula}
#' }
#'
#' @return individual or summation estimating function values
#'
#' @export
get.psi.ipw <- function(data, g, args, ps.wts = NULL, return.sums = T) {
## unpack arguments
list2env(args, envir = environment())
## design matrix
X <- mod.mat(trms = terms(as.formula(formula)),
data = data)
## extract dimensions
len.msm <- ncol(X)                                         # dim of msm params
len.ps <- ncol(model.matrix(terms(as.formula(ps.formula)), # PS model params
data = data))                  # dim of ps params
ind.A <- grepl("A", colnames(data))                        # exposure columns
len.A <- sum(ind.A)
## get PS weights if not supplied
if (is.null(ps.wts)) {
# extract PS model params
mean.a <- colMeans(as.matrix(A)) }
if (is.vector(A)) cov.a <- var(A) else cov.a <- cov(A)
coef.a.l <- matrix(g[len.msm + 1:(len.A*len.ps)],
ncol = len.ps, byrow = F)
var.a.l <- exp(tail(g, len.A))
# PS weights
ps.wts <- get.SW(data = data, ps.formula = ps.formula,
coef.a.l = coef.a.l, var.a.l = var.a.l,
mean.a = mean.a, cov.a = cov.a)
}
## IPW estimation
ipw.res <- fit.ipw.mccs(
data = datstar,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = ipw.args)
load_all()
library(devtools)
load_all()
load_all()
load_all()
library(devtools)
load_all()
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
## install the package
devtools::install_github(repo = "brian-d-richardson/mismex",
ref = "main")
## install the package
devtools::install_github(repo = "brian-d-richardson/mismex",
ref = "main")
knitr::opts_chunk$set(echo = TRUE)
## load the package
library(mismex)
## load additional packages
library(MASS)
library(dplyr)
library(tidyverse)
library(ggplot2)
n = 2000                                  # sample size
seed = 1                                  # random number seed
mc.seed <- 123                            # MCCS seed
cov.e = 0.0001
B = 1
inv.link <- inv.ident                     # inverse link
d.inv.link <- d.inv.ident                 # derivative of inverse link
g <- c(1.5, 0.7, 0.9, -0.6, -0.7, 0.4)    # outcome model parameters
formula <- "~A*L1 + A*L2"                 # outcome model formula
ps.formula <- "~L1 + L2"                  # propensity score model formula
ipw.formula <- "~A"                       # MSM formula
set.seed(seed)
L1 <- rbinom(n, 1, 0.5)                                  # confounder 1
L2 <- rnorm(n, 1, sqrt(0.5))                             # confounder 2
A <- rnorm(n, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))            # exposure
EY <- inv.link(model.matrix(as.formula(formula)) %*% g)  # mean of outcome
Y <- rnorm(n, EY, sqrt(0.16))                            # outcome
Astar <- A + rnorm(n, 0, sqrt(cov.e))                    # mismeasured A
head(datstar, 5)
set.seed(seed)
L1 <- rbinom(n, 1, 0.5)                                  # confounder 1
L2 <- rnorm(n, 1, sqrt(0.5))                             # confounder 2
A <- rnorm(n, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))            # exposure
a <- seq(min(A), max(A), length = 4)                     # grid of exposures
EY <- inv.link(model.matrix(as.formula(formula)) %*% g)  # mean of outcome
Astar <- A + rnorm(n, 0, sqrt(cov.e))                    # mismeasured A
datstar <- data.frame(Y, A = Astar, L1, L2)              # mismeasured data
head(datstar, 5)
## g-formula arguments
gfmla.args <- list(formula = formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## naive estimator
gfmla.naive <- fit.glm(data = datstar,
args = gfmla.args,
return.var = F)$est
## grid of possible B values
B.grid <- seq(1, 50, by = 2)
## G-formula
gfmla.res <- fit.gfmla.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = gfmla.args)
cbind(est = round(gfmla.res$est, 2),
stde = round(sqrt(diag(gfmla.res$var)), 2))
## IPW arguments
ipw.args <- list(formula = ipw.formula,
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## IPW estimation
ipw.res <- fit.ipw.mccs(
data = datstar,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = ipw.args)
cbind(est = round(ipw.res$est, 2),
stde = round(sqrt(diag(ipw.res$var)), 2))
## arguments for double robust estimation
dr.args <- list(formula = formula,
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## Double Robust
dr.res <- fit.dr.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = dr.args)
## Double Robust
dr.res <- fit.dr.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = dr.args)
cbind(est = round(dr.res$est, 2),
stde = round(sqrt(diag(dr.res$var)), 2))
## Known PS weights
ps.wts <- dnorm(A, mean(A), sd(A)) /
dnorm(A, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))
cbind(est = round(dr.res.known.wts$est, 2),
stde = round(sqrt(diag(dr.res.known.wts$var)), 2))
## Known PS weights
ps.wts <- dnorm(A, mean(A), sd(A)) /
dnorm(A, 2 + 0.9*L1 - 0.6*L2, sqrt(1.1))
## Double Robust (known weights)
dr.res.known.wts <- fit.dr.mccs(
data = datstar,
a = a,
cov.e = cov.e,
B = B,
mc.seed = mc.seed,
return.var = TRUE,
args = dr.args,
ps.wts = ps.wts)
cbind(est = round(dr.res.known.wts$est, 2),
stde = round(sqrt(diag(dr.res.known.wts$var)), 2))
