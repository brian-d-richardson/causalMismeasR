# Y density
fy <- function(y, x, B, s2) dnorm(x = y, mean = mu(x, B), sd = sqrt(s2))
# full data score vector
SF <- function(y, x, B, s2) {
cbind((y - mu(x, B)) * d.mu(x, B),
(y - mu(x, B)) ^ 2 - s2)
}
# generate data -----------------------------------------------------------
X <- rexp(n, x.rate)                            # censored covariate
C <- rexp(n, c.rate)                            # censoring time
W <- ifelse(X <= C, X, C)                       # observed covariate
Delta <- ifelse(X <= C, 1, 0)                   # uncensored indicator
Y <- rnorm(n, cbind(1, X) %*% B, sd = sqrt(s2)) # outcome
dat0 <- data.frame(Y, W = X, Delta = 1)         # oracle data
dat <- data.frame(Y, W, Delta)                  # observed data
datcc <- dat[Delta == 1,]                       # complete case data
# create quadrature rules -------------------------------------------------
# X quadrature
x.nds <- seq(10^-6, max(X), length = mx)
x.wts <- eta1(x.nds) / sum(eta1(x.nds))
# C quadrature
c.nds <- seq(10^-6, max(C), length = mc)
c.wts <- eta2(c.nds) / sum(eta2(c.nds))
# Y quadrature
gq <- gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
# evaluate estimating functions -------------------------------------------
# oracle
S0 <- get.Scc(dat = dat0, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF),
return.sums = F)
assess.ee(S0)
# complete case
Scc <- get.Scc(dat = dat, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF),
return.sums = F)
assess.ee(Scc)
# MLE
Sml <- get.Sml(dat = dat, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts),
return.sums = F)
assess.ee(Sml)
# semiparametric efficient score
Seff <- get.Seff(dat = dat, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy, eta1 = eta1,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts),
return.sums = F)
assess.ee(Seff)
# estimate beta -----------------------------------------------------------
# oracle
B0 <- get.root(dat = dat0, score = get.Scc, start = c(0, 0, 0))
B0
SF(
y = dat$Y[dat$Delta == 1],
x = dat$W[dat$Delta == 1],
B = B, s2 = s2)
Bcc <- get.root(dat = dat, score = get.Scc, start = c(0, 0))
Bcc
# complete case
Bcc <- get.root(dat = dat, score = get.Scc, start = c(0, 0, 0))
Bcc
score = get.Scc
start = c(0, 0, 0)
start = c(0, 0, log(s2))
start
rootSolve::multiroot(
f = function(theta) score(dat = dat, args = args,
B = theta[-1], s2 = exp(tail(theta, 1))),
start = start)
colMeans(SF(Y, X, B, s2))
B
colMeans(SF(Y, X, B, 1))
colMeans(SF(Y, X, B, 2))
rootSolve::multiroot(
f = function(theta) score(dat = dat, args = args,
B = theta[-1], s2 = exp(tail(theta, 1))),
start = start)
score(dat = dat, args = args,
B = theta[-1], s2 = exp(tail(theta, 1)))
theta = start
score(dat = dat, args = args,
B = theta[-1], s2 = exp(tail(theta, 1)))
exp(tail(theta, 1))
seq(0.01, 1, 0.01)
vapply(seq(0.01, 1, 0.01), function(s) SF(Y, X, B, s), numeric(3))
vapply(seq(0.01, 1, 0.01), function(s) colSums(SF(Y, X, B, s)), numeric(3))
AA <- t(vapply(seq(0.01, 1, 0.01), function(s) colSums(SF(Y, X, B, s)), numeric(3)))
View(AA)
plot(seq(0.01, 1, 0.01), AA[,1])
SF <- function(y, x, B, s2) {
cbind((y - mu(x, B)) * d.mu(x, B) / s2,
(y - mu(x, B)) ^ 2 - s2)
}
# generate data -----------------------------------------------------------
X <- rexp(n, x.rate)                            # censored covariate
C <- rexp(n, c.rate)                            # censoring time
W <- ifelse(X <= C, X, C)                       # observed covariate
Delta <- ifelse(X <= C, 1, 0)                   # uncensored indicator
Y <- rnorm(n, cbind(1, X) %*% B, sd = sqrt(s2)) # outcome
dat0 <- data.frame(Y, W = X, Delta = 1)         # oracle data
dat <- data.frame(Y, W, Delta)                  # observed data
datcc <- dat[Delta == 1,]                       # complete case data
# create quadrature rules -------------------------------------------------
# X quadrature
x.nds <- seq(10^-6, max(X), length = mx)
x.wts <- eta1(x.nds) / sum(eta1(x.nds))
# C quadrature
c.nds <- seq(10^-6, max(C), length = mc)
c.wts <- eta2(c.nds) / sum(eta2(c.nds))
# Y quadrature
gq <- gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
# evaluate estimating functions -------------------------------------------
# oracle
S0 <- get.Scc(dat = dat0, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF),
return.sums = F)
assess.ee(S0)
# complete case
Scc <- get.Scc(dat = dat, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF),
return.sums = F)
assess.ee(Scc)
# MLE
Sml <- get.Sml(dat = dat, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts),
return.sums = F)
assess.ee(Sml)
# semiparametric efficient score
Seff <- get.Seff(dat = dat, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy, eta1 = eta1,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts),
return.sums = F)
assess.ee(Seff)
# estimate beta -----------------------------------------------------------
# oracle
B0 <- get.root(dat = dat0, score = get.Scc, start = c(0, 0, 0))
B0
plot(seq(0.01, 1, 0.01), AA[,3])
start = c(0, 0)
rootSolve::multiroot(
f = function(theta) score(dat = dat, args = args,
B = theta[-1], s2 = s2),
start = start)
rootSolve::multiroot(
f = function(theta) score(dat = dat, args = args,
B = theta[-1], s2 = s2)[1:2],
start = start)
score(dat = dat, args = args,
B = theta[-1], s2 = s2)[1:2]
rootSolve::multiroot(
f = function(theta) score(dat = dat, args = args,
B = theta, s2 = s2)[1:2],
start = start)
B
start = c(1, 2, log(s2))
rootSolve::multiroot(
f = function(theta) score(dat = dat, args = args,
B = theta[-1], s2 = exp(tail(theta, 1))),
start = start)
setwd("C:/Users/Brian Richardson/OneDrive - University of North Carolina at Chapel Hill/Desktop/CFAR/Projects in Progress/Confounding and Measurement Error/causalMismeasR")
rm(list = ls())
library(dplyr)
library(tidyverse)
library(ggplot2)
library(ggh4x)
library(kableExtra)
# load simulation results from each of 10 clusters
sim.out.list <- lapply(
X = 0:9,
FUN = function(clust) {
cbind(clust,
read.csv(paste0("sim_data/cme_ipw/sd",
clust, ".csv")))
})
# combine simulation results into 1 data frame
sim.out <- bind_rows(sim.out.list)
colnames(sim.out)[30:53] <- gsub("se", "stde", colnames(sim.out)[30:53])
# true MSM parameters
g <- c(0.45, 0.20, 0.15, 0.15)
# number of sims per setting
n.rep <- nrow(sim.out) / n_distinct(dplyr::select(sim.out, n, B, vare))
# make long data frame
sim.out.long <- sim.out %>%
pivot_longer(cols = starts_with("ghat") | starts_with("stde"),
names_to = "method.param",
values_to = "val") %>%
mutate(method = factor(substr(method.param, 6, 7),
levels = c("OL", "OI",
"NL", "NI",
"CL", "CI")),
param = factor(substr(method.param, 9, 9)),
name = factor(substr(method.param, 1, 4)),
g.true = g[param]) %>%
dplyr::select(-method.param) %>%
group_by(clust, n, B, vare, method, param, name) %>%
mutate(id = row_number()) %>%
pivot_wider(names_from = name,
values_from = val,
id_cols = c(clust, n, B, vare, method,
param, g.true, id))
# summarize proportion of missing data by setting
sim.out.long %>%
filter(param == 1) %>%
group_by(method, n, B, vare) %>%
summarise(prop.error = mean(is.na(ghat))) %>%
filter(prop.error > 0) %>%
ungroup()
# extract simulation parameters
n <- unique(sim.out$n)
B <- unique(sim.out$B)
vare <- unique(sim.out$vare)
# make labels for plots
method.labs <- c("Oracle Linear",
"Naive Linear",
"Corrected Linear",
"Oracle IPW",
"Naive IPW",
"Corrected IPW")
names(method.labs) <- c("OL", "NL", "CL",
"OI", "NI", "CI")
n.labs <- paste0("n = ", n)
names(n.labs) <- n
B.labs <- paste0("B = ", B)
names(B.labs) <- B
vare.labs <- paste0("sigma_e = ", vare)
names(vare.labs) <- vare
param.labs <- paste0("gamma", 0:3)
names(param.labs) <- 1:4
# separate plots for each sample size
plot.by.n <- function(n., vare. = vare, est_cutoff = Inf) {
ggplot(
data = filter(sim.out.long,
n == n.,
vare %in% vare.,
abs(ghat - g.true) < est_cutoff),
aes(x = method,
y = ghat,
fill = method)) +
geom_boxplot() +
stat_summary(fun = mean,
geom = "point",
shape = 8,
size = 2,
orientation = "x",
show.legend = F) +
geom_hline(aes(yintercept = g.true),
linetype = "dashed",
color = "orange") +
facet_grid(vare ~ param,
scales = "free",
labeller = labeller(vare = vare.labs,
param = param.labs)) +
labs(y = "Parameter Estimate",
fill = "Method") +
ggtitle(paste0("Empirical Distribution of Parameter Estimates"),
subtitle = paste0("sample size n = ", n., "; ",
n.rep, " simulations per setting")) +
theme_bw() +
theme(axis.title.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank()) +
scale_fill_discrete(labels = method.labs)
}
View(sim.out)
plot.by.n(800)
View(sim.out)
View(sim.out.list)
# separate plots for each sample size
plot.by.var <- function(vare. = 0.05, est_cutoff = Inf) {
ggplot(
data = filter(sim.out.long,
n == n.,
vare %in% vare.,
abs(ghat - g.true) < est_cutoff),
aes(x = method,
y = ghat,
fill = method)) +
geom_boxplot() +
stat_summary(fun = mean,
geom = "point",
shape = 8,
size = 2,
orientation = "x",
show.legend = F) +
geom_hline(aes(yintercept = g.true),
linetype = "dashed",
color = "orange") +
facet_grid(n ~ param,
scales = "free",
labeller = labeller(n = n.labs,
param = param.labs)) +
labs(y = "Parameter Estimate",
fill = "Method") +
ggtitle(paste0("Empirical Distribution of Parameter Estimates"),
subtitle = paste0(n.rep, " simulations per setting")) +
theme_bw() +
theme(axis.title.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank()) +
scale_fill_discrete(labels = method.labs)
}
plot.by.var()
# separate plots for each sample size
plot.by.var <- function(vare. = 0.05, est_cutoff = Inf) {
ggplot(
data = filter(sim.out.long,
vare == vare.,
abs(ghat - g.true) < est_cutoff),
aes(x = method,
y = ghat,
fill = method)) +
geom_boxplot() +
stat_summary(fun = mean,
geom = "point",
shape = 8,
size = 2,
orientation = "x",
show.legend = F) +
geom_hline(aes(yintercept = g.true),
linetype = "dashed",
color = "orange") +
facet_grid(n ~ param,
scales = "free",
labeller = labeller(n = n.labs,
param = param.labs)) +
labs(y = "Parameter Estimate",
fill = "Method") +
ggtitle(paste0("Empirical Distribution of Parameter Estimates"),
subtitle = paste0(n.rep, " simulations per setting")) +
theme_bw() +
theme(axis.title.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank()) +
scale_fill_discrete(labels = method.labs)
}
plot.by.var()
tbl <- sim.out.long %>%
group_by(param, method, n, B, vare) %>%
summarise(bias = mean(ghat - g.true, na.rm = T),
emp.se = sd(ghat, na.rm = T),
est.se = mean(stde)) %>%
gather(key, value, bias:est.se) %>%
unite(Group, param, key) %>%
spread(Group, value)
setNames(tbl, sub(".+_", "", names(tbl))) %>%
kable(digits = 3) %>%
kable_styling("striped") %>%
add_header_above(c(" " = 4,
"Component 1" = 3,
"Component 2" = 3,
"Component 3" = 3,
"Component 4" = 3))
rm(list = ls())
library(dplyr)
library(tidyverse)
library(ggplot2)
library(ggh4x)
library(kableExtra)
# load simulation results from each of 10 clusters
sim.out.list <- lapply(
X = 0:9,
FUN = function(clust) {
cbind(clust,
read.csv(paste0("sim_data/cme_ipw/sd",
clust, ".csv")))
})
# combine simulation results into 1 data frame
sim.out <- bind_rows(sim.out.list)
colnames(sim.out)[30:53] <- gsub("se", "stde", colnames(sim.out)[30:53])
# true MSM parameters
g <- c(0.45, 0.20, 0.15, 0.15)
# number of sims per setting
n.rep <- nrow(sim.out) / n_distinct(dplyr::select(sim.out, n, B, vare))
# make long data frame
sim.out.long <- sim.out %>%
pivot_longer(cols = starts_with("ghat") | starts_with("stde"),
names_to = "method.param",
values_to = "val") %>%
mutate(method = factor(substr(method.param, 6, 7),
levels = c("OL", "OI",
"NL", "NI",
"CL", "CI")),
param = factor(substr(method.param, 9, 9)),
name = factor(substr(method.param, 1, 4)),
g.true = g[param]) %>%
dplyr::select(-method.param) %>%
group_by(clust, n, B, vare, method, param, name) %>%
mutate(id = row_number()) %>%
pivot_wider(names_from = name,
values_from = val,
id_cols = c(clust, n, B, vare, method,
param, g.true, id))
# summarize proportion of missing data by setting
sim.out.long %>%
filter(param == 1) %>%
group_by(method, n, B, vare) %>%
summarise(prop.error = mean(is.na(ghat))) %>%
filter(prop.error > 0) %>%
ungroup()
# extract simulation parameters
n <- unique(sim.out$n)
B <- unique(sim.out$B)
vare <- unique(sim.out$vare)
# make labels for plots
method.labs <- c("Oracle Linear",
"Naive Linear",
"Corrected Linear",
"Oracle IPW",
"Naive IPW",
"Corrected IPW")
names(method.labs) <- c("OL", "NL", "CL",
"OI", "NI", "CI")
n.labs <- paste0("n = ", n)
names(n.labs) <- n
B.labs <- paste0("B = ", B)
names(B.labs) <- B
vare.labs <- paste0("sigma_e = ", vare)
names(vare.labs) <- vare
param.labs <- paste0("gamma", 0:3)
names(param.labs) <- 1:4
# separate plots for each sample size
plot.by.var <- function(vare. = 0.05, est_cutoff = Inf) {
ggplot(
data = filter(sim.out.long,
vare == vare.,
abs(ghat - g.true) < est_cutoff),
aes(x = method,
y = ghat,
fill = method)) +
geom_boxplot() +
stat_summary(fun = mean,
geom = "point",
shape = 8,
size = 2,
orientation = "x",
show.legend = F) +
geom_hline(aes(yintercept = g.true),
linetype = "dashed",
color = "orange") +
facet_grid(n ~ param,
scales = "free",
labeller = labeller(n = n.labs,
param = param.labs)) +
labs(y = "Parameter Estimate",
fill = "Method") +
ggtitle(paste0("Empirical Distribution of Parameter Estimates"),
subtitle = paste0(n.rep, " simulations per setting")) +
theme_bw() +
theme(axis.title.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank()) +
scale_fill_discrete(labels = method.labs)
}
plot.by.var()
tbl <- sim.out.long %>%
group_by(param, method, n, B, vare) %>%
summarise(bias = mean(ghat - g.true, na.rm = T),
emp.se = sd(ghat, na.rm = T),
est.se = mean(stde)) %>%
gather(key, value, bias:est.se) %>%
unite(Group, param, key) %>%
spread(Group, value)
setNames(tbl, sub(".+_", "", names(tbl))) %>%
kable(digits = 3) %>%
kable_styling("striped") %>%
add_header_above(c(" " = 4,
"Component 1" = 3,
"Component 2" = 3,
"Component 3" = 3,
"Component 4" = 3))
# separate plots for each sample size
plot.se.by.vare <- function(vare. = vare) {
ggplot(
data = filter(sim.out.long,
vare == vare.),
aes(x = method,
y = stde,
fill = method)) +
geom_boxplot() +
stat_summary(fun = mean,
geom = "point",
shape = 8,
size = 2,
orientation = "x",
show.legend = F) +
facet_grid(n ~ param,
scales = "free",
labeller = labeller(n = n.labs,
param = param.labs)) +
labs(y = "Estimated Standard Error",
fill = "Method") +
ggtitle("Distribution of Estimated Standard Errors",
subtitle = paste0(n.rep, " simulations per setting")) +
theme_bw() +
theme(axis.title.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank()) +
scale_fill_discrete(labels = method.labs)
}
plot.se.by.vare
plot.se.by.vare()
plot.se.by.vare() +
ylim(0, 0.2)
