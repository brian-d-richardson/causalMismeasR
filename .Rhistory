B <- BV$B[1:3]; V <- BV$V[1:3, 1:3]
Yhat <- Xnew %*% B
Yhat.se <- sqrt(diag(Xnew %*% V %*% t(Xnew)))
pred <- data.frame(
method = m,
int = Xnew[,1],
X = Xnew[,2],
Z = factor(Xnew[,3]),
Yhat = Yhat,
Ylower = Yhat - qnorm(0.975) * Yhat.se,
Yupper = Yhat + qnorm(0.975) * Yhat.se
)
})
Yhat.list <- lapply(
names(method.labs),
function(m) {
BV <- readRDS(paste0("derived_data/enroll/", m, "_res"))
B <- BV$B[1:3]; V <- BV$V[1:3, 1:3]
Yhat <- Xnew %*% B
Yhat.se <- sqrt(diag(Xnew %*% V %*% t(Xnew)))
pred <- data.frame(
method = m,
int = Xnew[,1],
X = Xnew[,2],
Z = factor(Xnew[,3]),
Yhat = Yhat,
Ylower = Yhat - qnorm(0.975) * Yhat.se,
Yupper = Yhat + qnorm(0.975) * Yhat.se
)
})
m = "cc_res"
paste0("derived_data/enroll/", m, "_res")
BV <- readRDS(paste0("derived_data/enroll/", m, "_res"))
read.csv(paste0("derived_data/enroll/", , "res.csv"))
paste0("derived_data/enroll/", m, "_res")
readRDS(paste0("derived_data/enroll/", m, "_res"))
BV <- readRDS(paste0("derived-data/enroll/", m, "_res"))
Yhat.list <- lapply(
names(method.labs),
function(m) {
BV <- readRDS(paste0("derived-data/enroll/", m, "_res"))
B <- BV$B[1:3]; V <- BV$V[1:3, 1:3]
Yhat <- Xnew %*% B
Yhat.se <- sqrt(diag(Xnew %*% V %*% t(Xnew)))
pred <- data.frame(
method = m,
int = Xnew[,1],
X = Xnew[,2],
Z = factor(Xnew[,3]),
Yhat = Yhat,
Ylower = Yhat - qnorm(0.975) * Yhat.se,
Yupper = Yhat + qnorm(0.975) * Yhat.se
)
})
Yhats <- do.call(rbind, Yhat.list)
## plot fitted lines and 95% confidence intervals
ggplot() +
#geom_point(data = filter(dat, Delta == 1),
#           aes(x = W,
#               y = Y),
#           alpha = 0.2) +
geom_line(data = Yhats,
aes(x = X,
y = Yhat,
color = Z)) +
geom_ribbon(data = Yhats,
aes(x = X,
ymin = Ylower,
ymax = Yupper,
color = Z,
fill = Z),
alpha = 0.5) +
facet_grid(~ method) +
theme_bw()
## plot fitted lines and 95% confidence intervals
ggplot() +
#geom_point(data = filter(dat, Delta == 1),
#           aes(x = W,
#               y = Y),
#           alpha = 0.2) +
geom_line(data = Yhats,
aes(x = X,
y = Yhat,
color = Z)) +
geom_ribbon(data = Yhats,
aes(x = X,
ymin = Ylower,
ymax = Yupper,
color = Z,
fill = Z),
alpha = 0.5) +
facet_grid(~ method,
labeller = labeller(mehtod = method.labs)) +
theme_bw()
method.labs
###############################################################################
###############################################################################
# ENROLL-HD Data Analysis
# Brian Richardson
# 2024-05-01
###############################################################################
###############################################################################
# setup -------------------------------------------------------------------
rm(list = ls())
library(dplyr)
library(ggplot2)
setwd("C:/Users/Brian Richardson/OneDrive - University of North Carolina at Chapel Hill/Desktop/Garcia Lab/Research/Projects-Active/HDSP/Analysis")
# load data ---------------------------------------------------------------
res <- read.csv("derived-data/enroll/res.csv")
dat <- read.csv("derived-data/enroll/dat.csv") %>%
mutate(Z = factor(Z))
# prep for plots ----------------------------------------------------------
# underscore (\u2081) not working in plot
param.labs <- c("\u03B21", "\u03B22", "\u03B23", "log\u03C3\u00B2")
names(param.labs) <- 1:4
method.labs <- c("CC", "MLE", "Semipar. (Nonpar.)", "Semipar (Param.)")
names(method.labs) <- c("cc", "ml", "sp_nonpar", "sp_param")
# view results ------------------------------------------------------------
## Plot estimates and CIs
ggplot(
data = res,
aes(x = method,
y = est,
ymin = ci.lower,
ymax = ci.upper,
color = method)) +
geom_point() +
geom_errorbar() +
facet_wrap(~ param, ncol = 2,
labeller = labeller(param = param.labs),
scales = "free_y") +
labs(y = "Estimate with 95% CI",
color = "Method") +
ggtitle("ENROLL-HD Analysis Results",
subtitle = "Model: log(TMS + 1) ~ (Time to Diagnosis) + CAP Category") +
theme_bw() +
theme(legend.position = "bottom",
axis.title.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank())
## Plot Variances
ggplot(
data = res,
aes(x = method,
y = ste^2,
color = method)) +
geom_point(size = 2) +
facet_wrap(~ param, scales = "free_y",
labeller = label_both) +
labs(y = "Variance of Estimator") +
ggtitle("ENROLL-HD Analysis Results",
subtitle = "Model: log(TMS + 1) ~ (Time to Diagnosis) + CAP Category") +
theme_bw() +
theme(legend.position = "bottom",
axis.title.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank())
# plot regression lines ---------------------------------------------------
## get predicted values over range of X values
len.new <- 100
Xnew <- as.matrix(data.frame(
int = 1,
X = seq(min(dat$W), max(dat$W), length = len.new),
Z = rep(0:1, each = len.new)
))
Yhat.list <- lapply(
names(method.labs),
function(m) {
BV <- readRDS(paste0("derived-data/enroll/", m, "_res"))
B <- BV$B[1:3]; V <- BV$V[1:3, 1:3]
Yhat <- Xnew %*% B
Yhat.se <- sqrt(diag(Xnew %*% V %*% t(Xnew)))
pred <- data.frame(
method = m,
int = Xnew[,1],
X = Xnew[,2],
Z = factor(Xnew[,3]),
Yhat = Yhat,
Ylower = Yhat - qnorm(0.975) * Yhat.se,
Yupper = Yhat + qnorm(0.975) * Yhat.se
)
})
Yhats <- do.call(rbind, Yhat.list)
## plot fitted lines and 95% confidence intervals
ggplot() +
#geom_point(data = filter(dat, Delta == 1),
#           aes(x = W,
#               y = Y),
#           alpha = 0.2) +
geom_line(data = Yhats,
aes(x = X,
y = Yhat,
color = Z)) +
geom_ribbon(data = Yhats,
aes(x = X,
ymin = Ylower,
ymax = Yupper,
color = Z,
fill = Z),
alpha = 0.5) +
facet_grid(~ method,
labeller = labeller(mehtod = method.labs)) +
theme_bw()
View(Yhats)
## plot fitted lines and 95% confidence intervals
ggplot() +
#geom_point(data = filter(dat, Delta == 1),
#           aes(x = W,
#               y = Y),
#           alpha = 0.2) +
geom_line(data = Yhats,
aes(x = X,
y = Yhat,
color = Z)) +
geom_ribbon(data = Yhats,
aes(x = X,
ymin = Ylower,
ymax = Yupper,
color = Z,
fill = Z),
alpha = 0.5) +
facet_grid(~ method,
labeller = labeller(method = method.labs)) +
theme_bw()
## plot fitted lines and 95% confidence intervals
ggplot() +
#geom_point(data = filter(dat, Delta == 1),
#           aes(x = W,
#               y = Y),
#           alpha = 0.2) +
geom_line(data = Yhats,
aes(x = X,
y = Yhat,
color = Z)) +
geom_ribbon(data = Yhats,
aes(x = X,
ymin = Ylower,
ymax = Yupper,
color = Z,
fill = Z),
alpha = 0.5) +
facet_wrap(~ method,
labeller = labeller(method = method.labs)) +
theme_bw()
setwd("C:/Users/Brian Richardson/OneDrive - University of North Carolina at Chapel Hill/Desktop/CFAR/Projects in Progress/Confounding and Measurement Error/mismex")
library(MASS); library(devtools); load_all()
n = 800; vare = 0.0001; B = 2; seed = 1;
gg <- c(0.4, 0.15, 0.15, 0.2,
0.1, 0.1, 0, -0.1)                     # Y|A,L parameters
glm.formula <- "~A1*L + A2*L + A3*L"           # Y|A,L model formula
ipw.formula <- "~A1 + A2 + A3"                 # MSM formula
ps.formula <- "~L"                             # PS model formula
inv.link <- inv.ident;                         # MSM link function
d.inv.link <- d.inv.ident;                     # MSM derivative of link
cov.e <- diag(c(vare, vare, 0))                # measurement error variance
mc.seed <- 123                                 # MCCS seed value
coef.a.l <- matrix(
data = c(0, 0.4, 0, -0.4, 0.2, -0.1),        # coefs in A|L model
nrow = 3, byrow = T)
var.a.l <- c(0.09, 0.09, 0.09)                 # variance of A|L
set.seed(seed)                                 # seed for reproducibility
L <- runif(n)                                  # confounder
A <- mvrnorm(n = n,                            # true exposure
mu = c(0, 0, 0),
Sigma = diag(var.a.l)) +
cbind(1, L) %*% t(coef.a.l)
colnames(A) = paste0("A", 1:3)
Astar <- A + mvrnorm(n = n,                    # mismeasured exposure
m = c(0, 0, 0),
Sigma = cov.e)
Y_prob <- cbind(1, A, L, A*L) %*% gg           # mean of binary outcome
Y_prob[Y_prob < 0] <- 0                        # correct Y_prob in rare cases
Y_prob[Y_prob > 1] <- 1
Y <- rbinom(n, 1, Y_prob)                      # binary outcome
colnames(A) <- colnames(Astar) <- c("A1", "A2", "A3")
dat0 <- data.frame(Y, A, L)                    # oracle data
datstar <- data.frame(Y, Astar, L)             # mismeasured data
len.A <- ncol(A)                               # dimension of A
mean.a <- colMeans(A)                          # marginal mean of A
cov.a <- cov(A)                                # marginal covariance of A
args.glm <- list(formula = glm.formula,        # arguments for fitting GLM
inv.link = inv.link,
d.inv.link = d.inv.link)
args.ipw <- list(formula = ipw.formula,        # arguments for fitting IPW
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
# (i) naive IPW estimator
res.NI <- fit.ipw(data = datstar,
args = args.ipw)
res.NI
# (ii) oracle IPW estimator
res.OI <- fit.ipw(data = dat0,
args = args.ipw,
start = res.NI$est[1:4])
res.OI
load_all()
gg <- c(0.4, 0.15, 0.15, 0.2,
0.1, 0.1, 0, -0.1)                     # Y|A,L parameters
glm.formula <- "~A1*L + A2*L + A3*L"           # Y|A,L model formula
ipw.formula <- "~A1 + A2 + A3"                 # MSM formula
ps.formula <- "~L"                             # PS model formula
inv.link <- inv.ident;                         # MSM link function
d.inv.link <- d.inv.ident;                     # MSM derivative of link
cov.e <- diag(c(vare, vare, 0))                # measurement error variance
mc.seed <- 123                                 # MCCS seed value
coef.a.l <- matrix(
data = c(0, 0.4, 0, -0.4, 0.2, -0.1),        # coefs in A|L model
nrow = 3, byrow = T)
var.a.l <- c(0.09, 0.09, 0.09)                 # variance of A|L
## generate data
set.seed(seed)                                 # seed for reproducibility
L <- runif(n)                                  # confounder
A <- mvrnorm(n = n,                            # true exposure
mu = c(0, 0, 0),
Sigma = diag(var.a.l)) +
cbind(1, L) %*% t(coef.a.l)
colnames(A) = paste0("A", 1:3)
Astar <- A + mvrnorm(n = n,                    # mismeasured exposure
m = c(0, 0, 0),
Sigma = cov.e)
Y_prob <- cbind(1, A, L, A*L) %*% gg           # mean of binary outcome
Y_prob[Y_prob < 0] <- 0                        # correct Y_prob in rare cases
Y_prob[Y_prob > 1] <- 1
Y <- rbinom(n, 1, Y_prob)                      # binary outcome
colnames(A) <- colnames(Astar) <- c("A1", "A2", "A3")
dat0 <- data.frame(Y, A, L)                    # oracle data
datstar <- data.frame(Y, Astar, L)             # mismeasured data
## store values for estimation
len.A <- ncol(A)                               # dimension of A
mean.a <- colMeans(A)                          # marginal mean of A
cov.a <- cov(A)                                # marginal covariance of A
args.glm <- list(formula = glm.formula,        # arguments for fitting GLM
inv.link = inv.link,
d.inv.link = d.inv.link)
args.ipw <- list(formula = ipw.formula,        # arguments for fitting IPW
ps.formula = ps.formula,
inv.link = inv.link,
d.inv.link = d.inv.link)
## estimate MSM parameters
# (i) naive IPW estimator
res.NI <- fit.ipw(data = datstar,
args = args.ipw)
load_all()
# (i) naive IPW estimator
res.NI <- fit.ipw(data = datstar,
args = args.ipw)
load_all()
# (i) naive IPW estimator
res.NI <- fit.ipw(data = datstar,
args = args.ipw)
# (ii) oracle IPW estimator
res.OI <- fit.ipw(data = dat0,
args = args.ipw,
start = res.NI$est[1:4])
# (iii) MCCS IPW estimator
res.CI <- fit.ipw.mccs(data = datstar,
args = args.ipw,
cov.e = cov.e, B = B, mc.seed = mc.seed,
mean.a = colMeans(Astar),
cov.a = cov(Astar) - cov.e,
start = res.NI$est[1:4])
ret <- c(
n, vare, B, seed,
res.OI$est[1:4], res.NI$est[1:4], res.CI$est[1:4],
diag(res.OI$var)[1:4], diag(res.NI$var)[1:4], diag(res.CI$var)[1:4],
diag(res.OI$bc.var)[1:4], diag(res.NI$bc.var)[1:4], diag(res.CI$bc.var)[1:4]
)))
diag(res.OI$var)[1:4]
diag(res.OI$bc.var)[1:4]
diag(res.NI$bc.var)[1:4]
# combine results: estimates and std errors for 4 parameters
ret <- c(
n, vare, B, seed,
res.OI$est[1:4], res.NI$est[1:4], res.CI$est[1:4],
sqrt(c(
diag(res.OI$var)[1:4], diag(res.NI$var)[1:4], diag(res.CI$var)[1:4],
diag(res.OI$bc.var)[1:4], diag(res.NI$bc.var)[1:4], diag(res.CI$bc.var)[1:4]
)))
ret
names(ret) <- c(
"n", "vare", "B", "seed",
apply(tidyr::expand_grid(
c("ghat", "stde", "bste"),
c("OI", "NI", "CI"),
1:4), 1, paste, collapse="."))
ret
rm(list = ls())
library(rootSolve)
library(MASS)
library(mvtnorm)
library(tidyr)
library(devtools)
#setwd(dirname(getwd()))
load_all()
# baseline seed (specific to cluster)
args <- 1#commandArgs(TRUE)
base.seed <- 10^6 * as.integer(args)
# number of sims per cluster
n.sim <- 1
# varied parameters
n <- 800                          # sample size
B <- 80                           # number of MC replicates
vare <- 0.05                      # measurement error variance for A1, A2
n <- 800                          # sample size
B <- 80                           # number of MC replicates
vare <- 0.05                      # measurement error variance for A1, A2
# run simulations ---------------------------------------------------------
# create simulation input
sim.in <- expand.grid(n = n,
B = B,
vare = vare,
sim.id = 1:n.sim + base.seed)
# run simulations
sim.out <- pbapply::pbvapply(
X = 1:nrow(sim.in),
FUN = function(ii) {
sim.ipw(n = sim.in$n[ii],
B = sim.in$B[ii],
vare = sim.in$vare[ii],
seed = sim.in$sim.id[ii])
},
FUN.VALUE = numeric(40)) |>
t()
n <- 800                          # sample size
B <- 80                           # number of MC replicates
vare <- 0.05                      # measurement error variance for A1, A2
# run simulations ---------------------------------------------------------
# create simulation input
sim.in <- expand.grid(n = n,
B = B,
vare = vare,
sim.id = 1:n.sim + base.seed)
# run simulations
sim.out <- pbapply::pbvapply(
X = 1:nrow(sim.in),
FUN = function(ii) {
sim.ipw(n = sim.in$n[ii],
B = sim.in$B[ii],
vare = sim.in$vare[ii],
seed = sim.in$sim.id[ii])
},
FUN.VALUE = numeric(40)) |>
t()
View(sim.out)
library(MASS); library(devtools); load_all()
n = 800; a = 3; vare = 0.0025; B = 2; seed = 1;
cov.e <- vare                                   # var(epsilon)
mc.seed <- 123                                  # MC seed
inv.link <- inv.logit                           # inverse link
d.inv.link <- d.inv.logit                       # deriv of inv link
g <- c(-2, 0.7, -0.6, 0.4, -0.4, -0.2)          # outcome model parameters
formula <- "~A*L1 + A*L2"                       # outcome model formula
args <- list(formula = formula,                 # model fitting arguments
inv.link = inv.link,
d.inv.link = d.inv.link)
# according to DGP #1 in Blette submission
set.seed(seed)
L1 <- rbinom(n, 1, 0.5)                                        # confounder 1
L2 <- rbinom(n, 1, 0.2)                                        # confounder 2
A <- rnorm(n, 2 + 0.3*L1 - 0.5*L2, sqrt(0.35))
EY <- inv.link(model.matrix(as.formula(formula)) %*% g)        # mean of outcome
Y <- rbinom(n, 1, EY)                                          # outcome
Astar <- A + rnorm(n, 0, sqrt(cov.e))                          # mismeasured A
dat0 <- data.frame(Y, A, L1, L2)                 # oracle data
datstar <- data.frame(Y, Astar, L1, L2)          # mismeasured data
colnames(dat0) <- colnames(datstar) <- c("Y", "A", "L1", "L2")
# g-formula
gfmla.naive <- fit.gfmla(data = datstar, a = a, args = args)
# oracle g-formula
gfmla.oracle <- fit.gfmla(data = dat0, a = a, args = args,
start = gfmla.naive$est[1:length(g)])
# corrected g-formula
gfmla.mccs <- fit.gfmla.mccs(data = datstar, a = a, args = args,
cov.e = cov.e, B = B, mc.seed = mc.seed,
start = gfmla.naive$est[1:length(g)])
library(rootSolve)
library(MASS)
library(mvtnorm)
library(tidyr)
library(devtools)
#setwd(dirname(getwd()))
load_all()
# simulation parameters ---------------------------------------------------
# baseline seed (specific to cluster)
args <- 1#commandArgs(TRUE)
base.seed <- 10^6 * as.integer(args)
n.sim <- 1          # number of sims per cluster
a <- 0:4            # exposures at which to estimate E{Y(a)}
# varied parameters
n <- 800#c(800, 8000)                 # sample size
B <- 2                           # number of MC replicates
vare <- 0.0025                # measurement error variance for A1, A2
# run simulations ---------------------------------------------------------
# create simulation input
sim.in <- expand.grid(n = n,
B = B,
vare = vare,
sim.id = 1:n.sim + base.seed)
# run simulations
sim.out <- pbapply::pbvapply(
X = 1:nrow(sim.in),
FUN = function(ii) {
sim.gfmla.pos.vi(n = sim.in$n[ii],
B = sim.in$B[ii],
vare = sim.in$vare[ii],
a = a,
seed = sim.in$sim.id[ii])
},
FUN.VALUE = numeric(54)) |>
t()
View(sim.out)
